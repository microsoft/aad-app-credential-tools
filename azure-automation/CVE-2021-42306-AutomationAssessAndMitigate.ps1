<#
.SYNOPSIS
    This script is used to check which automation accounts are impacted by 
    CVE-2021-42306 and for each impacted account, it allows the user to remediate the issue. 

.DESCRIPTION
    CVE-2021-42306 has more details about the issue regarding the Azure-AD key credentials.
    This script will assess automation account which has configured RunAs accounts and checks 
    if the corresponding AAD application is impacted or not. If it is impacted, on confirmation 
    it will renew the key credentials of Azure-AD App by deleting the older certificate(s) and 
    uploading new self-signed certificate to the Azure-AD App, which will mitigate the issue.

    Prerequisites: 
    1. .NET framework 4.7.2 or later installed.
    2. Windows PowerShell version 5.1(64-bit) or later installed and run with Administrator permissions.
    3. Azure Az PowerShell module latest version installed, having minimum version Az.Accounts (2.5.4)`, `Az.Resources (4.4.0)` & `Az.Automation (1.7.1)` cmdlets
    4. You need the following permissions on the Azure user account:
        a. ‘Contributor’ access on the Azure subscription that has the Azure Automation account, and
        b. Owner permissions on the associated Run-As-Account Azure AD Application.

    Examples to run :
        1) To assess and mitigate single AppID - Ex:  .\CVE-2021-42306-AutomationAssessAndMitigate.ps1 -AppId 344456-2244-45674-8340-20d95505566
        2) To assess and mitigate set of subscriptions - Ex: .\CVE-2021-42306-AutomationAssessAndMitigate.ps1 - SubscriptionIds subId1,subId2

.PARAMETER SubscriptionIds
    [Optional] Assess and mitigate all the Automation accounts from the input subscriptions.

.PARAMETER AppId
    [Optional] Assess and mitigate Automation RunAs Azure-AD App.

.PARAMETER Env
    [Optional] Cloud environment name. 'AzureCloud' by default.

.PARAMETER NoMitigation
    [Optional] Skip all mitigation actions. Only complete the assessment.

.PARAMETER NoLogin
    [Optional] Skip login prompts. Requires an existing login in the current session.

.PARAMETER Verbose
    [Optional] Enable verbose logging

.EXAMPLE
    PS> .\CVE-2021-42306-AutomationAssessAndMitigate.ps1 -AppId <appId>

.EXAMPLE
    PS> .\CVE-2021-42306-AutomationAssessAndMitigate.ps1 -SubscriptionIds subId1,subId2

.NOTES
    1. If the runbooks uses RunAs Azure-AD App to access the resources through Az/AzureRM cmdlets, 
    access-tokens may become invalid due to certificate changes, and so jobs may fail. 
    In this case, jobs can be manually retried after mitigation.

    2. New self-signed certificate needs to be provisioned on all hybrid workers connected to that automation account.
    (https://docs.microsoft.com/en-us/azure/automation/automation-hrw-run-runbooks#runas-script)

    3. In case the jobs are critical, please follow manual mitigation steps.
        a. Renew the certificate using the manual steps mentioned in the [manage runas account documentation](https://docs.microsoft.com/en-us/azure/automation/manage-runas-account).
        b. Update the certificate on all HRWs that use the Run As Account for authentication ([steps](https://docs.microsoft.com/en-us/azure/automation/automation-hrw-run-runbooks#runas-script)).
        c. Wait for jobs which started before the certificate renewal to complete.
        d. Delete the older certificate from the AAD application.

.AUTHOR Microsoft

.VERSION 1.0
#>

#Requires -Modules @{ ModuleName="Az.Accounts"; ModuleVersion="2.5.4" },@{ ModuleName="Az.Resources"; ModuleVersion="4.4.0" },@{ ModuleName="Az.Automation"; ModuleVersion="1.7.1" }
#Requires -PSEdition Desktop
#Requires -RunAsAdministrator

[CmdletBinding()]
Param(
    [string[]]
    $SubscriptionIds,

    [string]
    $AppId,

    [switch]
    $NoMitigation,

    [switch]
    $NoLogin,

    # Max number of retries for List Applications or List ServicePrincipals MS Graph request
    [int]
    $MaxRetryLimitForGraphApiCalls = 5,

    [ValidateSet("AzureCloud", "AzureUSGovernment", "AzureChinaCloud")]
    [Parameter(Mandatory = $false, HelpMessage = "Cloud environment name. 'AzureCloud' by default")]
    [string]
    $Env = "AzureCloud"
)

function Show-Description {
    Write-Warning ""
    Write-Warning "The script can be used to run at a time on single AAD App( belong to automation) or set of subscriptions." 
    Write-Warning "Please note that the script will work for Automation managed RunAs AAD Apps, and if you are using Third-party/CA-signed certificates, please follow manual mitigation steps mentioned in Notes"
    Write-Warning ""

    Write-Warning "Prerequisites:"
    Write-Warning "1. .NET framework 4.7.2 or later installed."
    Write-Warning "2. Windows PowerShell version 5.1(64-bit) or later installed and run with Administrator permissions."
    Write-Warning "3. Azure Az PowerShell module latest version installed, having minimum version Az.Accounts (2.5.4)`, `Az.Resources (4.4.0)` & `Az.Automation (1.7.1)` cmdlets"
    Write-Warning "4. You need the following permissions on the Azure user account:"
    Write-Warning "    a. ‘Contributor’ access on the Azure subscription that has the Azure Automation account, and"
    Write-Warning "    b. Owner permissions on the associated Run-As-Account Azure AD Application."

    Write-Warning "Examples to run :"
    Write-Warning "    a. To assess and mitigate single AppID - Ex:  .\CVE-2021-42306-AutomationAssessAndMitigate.ps1 -AppId 344456-2244-45674-8340-20d95505566"
    Write-Warning "    b. To assess and mitigate set of subscriptions - Ex: .\CVE-2021-42306-AutomationAssessAndMitigate.ps1 - SubscriptionIds subId1,subId2"
}

Function Get-MSGraphEndpoint
{
    param(
        [string]
        $Env
    )

    switch ($Env)
    {
        "AzureCloud" { return "https://graph.microsoft.com" }
        "AzureChinaCloud" { return "https://microsoftgraph.chinacloudapi.cn" }
        "AzureUSGovernment" { return "https://graph.microsoft.us" }
        default { throw "$($Env) is not a valid cloud environment." }
    }
}

class AutomationAccount {
    [string] $Name
    [string] $ResourceId
    [string] $Region
    [string] $ResourceGroup
    [string] $SubscriptionId
    [string] $RunAsAppId
    [DateTimeOffset] $RunAsConnectionCreationTime
    [bool] $UsesThirdParytCert
}

$ImpactedAccounts = New-Object System.Collections.ArrayList

function Assess-Impact {
    Write-Output ""
    Write-Output "================================================="
    Write-Output "Started Assessing impacted Automation accounts..."
    Write-Output "================================================="

    # Get all automation accounts accessible to current user
    $queryPayload = @{
        query = 'resources | where type == "microsoft.automation/automationaccounts"'
        options = @{
        '$top' = 10000
        '$skip' = 0
        '$skipToken' = ""
        'resultFormat' = "table"
        }
    }
    $payload = $queryPayload | ConvertTo-Json

    $resp = Invoke-AzRestMethod -Path "/providers/Microsoft.ResourceGraph/resources?api-version=2021-03-01" -Method POST -Payload $payload
    $resp = $resp.Content | ConvertFrom-Json

    $allAccounts = New-Object System.Collections.ArrayList
    $defaultDate = (Get-Date 01-01-1970)
    foreach ($row in $resp.data.rows)
    {
        $a = [AutomationAccount]@{
            ResourceId = $row[0]
            Name = $row[1]
            Region = $row[5]
            ResourceGroup = $row[6]
            SubscriptionId = $row[7]
            RunAsAppId = ""
            RunAsConnectionCreationTime = $defaultDate
            UsesThirdParytCert = $false
        }
        Write-Debug "$($a.Name), $($a.Region), $($a.ResourceGroup), $($a.SubscriptionId)"

        $allAccounts.Add($a) > $null
    }

    Assess-ImpactBySubscriptionGroup $allAccounts
    Write-Output ""
    Write-Output "==================================================="
    Write-Output "Completed Assessing impacted Automation accounts..."
    Write-Output "==================================================="  
    Write-Output ""  
}

function Assess-ImpactBySubscriptionGroup {
    param ($accounts)

    if ($null -ne $SubscriptionIds -and $SubscriptionIds.Count -ne 0)
    {
        Write-Verbose "Filtering by subscription: $SubscriptionId"
        $accounts = $accounts | Where-Object { $_.SubscriptionId -in $SubscriptionIds }
    }

    # Group by subscription ID
    $accountsGroup = $accounts | Group-Object { $_.SubscriptionId }

    foreach ($item in $accountsGroup) {
        Write-Output ""
        Write-Output "Procesing accounts in subscription $($item.Name): $($item.Group.Count)"
        Select-AzSubscription -SubscriptionId $item.Name > $null

        foreach ($a in $item.Group) {
            Assess-Account $a
        }
    }
}

function Assess-ImpactByAppId {

    # Check aad app id is valid or not
    if ([string]::IsNullOrWhiteSpace($AppId))
    {
        Write-Verbose "Given AAD App ID is invalid, Provide valid AAD App ID: $AppId"
    }

    # Get the given aad app
    $aadApp = Get-AzADApplication -ApplicationId $AppId

    # Check if the AAD app belong to Azure automation
    if( $null -ne $aadApp -and $aadApp.HomePage.ToLower().Contains("providers/microsoft.automation/automationaccounts")) {

        $resoureDetails = ParseResourceId $aadApp.HomePage

        if( $null -ne $resoureDetails -and $resoureDetails.Count -eq 3 -and
            ![string]::IsNullOrWhiteSpace($resoureDetails[0]) -and ![string]::IsNullOrWhiteSpace($resoureDetails[1]) -and ![string]::IsNullOrWhiteSpace($resoureDetails[2])) {

                Write-Verbose "Given App ID belongs to Azure automation, proceeding for further accessment. Subscription: $($resoureDetails[0]), ResourceGroup: $($resoureDetails[1]), Automation account name: $($resoureDetails[2])"
                Select-AzSubscription -SubscriptionId $resoureDetails[0] > $null
                $account = Get-AzAutomationAccount -ResourceGroupName $resoureDetails[1] -Name $resoureDetails[2]
                $defaultDateTime = (Get-Date 01-01-1970)

                if( $null -ne $account){

                    $a = [AutomationAccount]@{
                        ResourceId = $aadApp.HomePage
                        Name = $account.AutomationAccountName
                        Region = $account.Location
                        ResourceGroup = $account.ResourceGroupName
                        SubscriptionId = $account.SubscriptionId
                        RunAsAppId = ""
                        RunAsConnectionCreationTime = $defaultDateTime
                        UsesThirdParytCert = $false
                    }
                    Assess-Account $a
                } else {
                    Write-Error "Unable to Assess Azure-AD App $($AppId) - Reason: Unable to find the automation account."
                }
            } else {
                Write-Error "Unable to Assess Azure-AD App $($AppId) - Reason: Unable to find the automation account."
            }
    } else {
        Write-Error "Unable to assess Azure-AD App $($AppId) - Reason: Application not Managed by Automation."
    }
}

function Assess-Account {
    param ([AutomationAccount] $account)

    Write-Verbose "Assessing account $($account.ResourceId)"
    # Get the RunAs connection
    $conn = Get-AzAutomationConnection -AutomationAccountName $account.Name -ResourceGroupName $account.ResourceGroup -Name "AzureRunAsConnection" -ErrorAction SilentlyContinue

    if ($null -ne $conn -and $conn.ConnectionTypeName -eq "AzureServicePrincipal") {
        $account.RunAsAppId = $conn.FieldDefinitionValues.ApplicationId
        $account.RunAsConnectionCreationTime = $conn.CreationTime

        Assess-CertificatesOnApp $account
    }
    else {
        Write-Verbose "Account $($a.ResourceId) is not impacted"
    }
}

function Assess-CertificatesOnApp {
    param ([AutomationAccount] $account)

    $url = "$($MsGraphEndpoint)/beta/applications?`$filter=appId eq '$($account.RunAsAppId)'&`$select=id,appId,keyCredentials"

    $resp = Make-MSGraphRequest -Url $url -MaxRetryLimit $MaxRetryLimitForGraphApiCalls

    if ($null -ne $resp -and $null -ne $resp.value.keyCredentials) {
        foreach ($keyCred in $resp.value.keyCredentials) {
            if (($keyCred.Key.Length -gt 0) -and ($keyCred.type -eq 'AsymmetricX509Cert') -and (($keyCred.usage -eq 'Verify') -or ($keyCred.usage -eq 'Encrypt'))) {
                # check cert is not expired
                if ((Get-Date $keyCred.endDateTime) -gt (Get-Date)) {
                    Assess-Certificate $account $keyCred
                }
            }
        }
    }
    else {
        Write-Error "Unable to Assess Account $($account.ResourceId) - Reason: Failed to retrieve metadata from Azure Graph API"
    }
}

# Remove unnecessary new line characters and whitespace in url
Function Trim-Url
{
    param(
        [string]
        $Url
    )

    return $Url -replace '`n','' -replace '\s+', ''
}

# Make MS Graph request with retry and exponential backoff
Function Make-MSGraphRequest
{
    param(
        [string]
        $Url,

        [int]
        $MaxRetryLimit,

        [int]
        $flatMinSeconds = 10,

        [bool]
        $AddConsistencyLevel
    )

    $headers = @{
        "Authorization" = "Bearer $($MsGraphToken)"
    }

    if ($AddConsistencyLevel) {
        $headers["ConsistencyLevel"] = "eventual"
    }

    for ($i=1; $i -le $MaxRetryLimit; $i+=1)
    {
        try
        {
            Write-Verbose "GET $($Url)"
            $result = Invoke-RestMethod -Uri $Url -Headers $headers -Method "GET" -Verbose:$false
            break
        }
        catch
        {
            if ($_.Exception.Response.StatusCode.value__ -eq 429)
            {
                # Sleep then retry (Exponential backoff)
                $sleepDuration = [Math]::Pow(2,$i) + $flatMinSeconds
                Write-Verbose "Retry after sleeping for $($sleepDuration) seconds"
                Start-Sleep -s $sleepDuration
                continue
            }

            if ($_.Exception.Response.StatusCode.value__ -eq 404)
            {
                Write-Warning "AAD Object not found. Query - '$($Url)'"
                break
            }
        }
    }

    if ($i -gt $MaxRetryLimit)
    {
        $Url = Trim-Url -Url $Url
        Write-Warning "Unexpected error while connecting to the Azure Graph API. URL - '$($Url)'"
    }

    return $result
}


function Assess-Certificate {
    param (
        [AutomationAccount] $account,
        $keyCred
    )

    $automationCertIssuerName = "DC=$($account.Name)_$($account.ResourceGroup)_$($account.SubscriptionId)"

    if ($keyCred.hasExtendedValue -eq $true) {
        $ImpactedAccounts.Add($account) > $null
        Write-Output "Account $($account.ResourceId) is impacted for cert: $($keyCred.customKeyIdentifier)"
    }
    else {
    }

    try {
        $certBytes = [Convert]::FromBase64String($keyCred.key)
        $cert = [System.Security.Cryptography.X509Certificates.X509Certificate2]::new($certBytes)
    }
    catch {
        Write-Error "Unable to assess impact for $($account.ResourceId) - Reason: Issue processing certificate."
    }

    if ($null -ne $cert) {
        if ($cert.Issuer -eq $automationCertIssuerName) {
            Write-Verbose "Account $($account.ResourceId) uses a self-signed cert with thumbprint: $($cert.Thumbprint)."
        }
        else {
            $account.UsesThirdParytCert = $true
            Write-Verbose "Account $($account.ResourceId) uses a third-party certificate with issuer: $($cert.Issuer)."
        }
        Write-Debug "issuer: $($cert.Issuer), subject: $($cert.Subject), expiry: $($cert.NotAfter), extValue: $($keyCred.hasExtendedValue)"
    }
}

function Mitigate-Incident {
    param (
        $accounts
    )

    if ($accounts.Count -eq 0) {
        Write-Output ""
        Write-Output "No impacted accounts to mitigate."
        return
    }

    Write-Output ""
    Write-Output "======================"
    Write-Output "Starting mitigation..."
    Write-Output "======================"
    $count = 0
    foreach ($a in $accounts)
    {
        if ($a.UsesThirdParytCert) {
            Write-Output "$($a.ResourceId) uses a third-party certificate."
            $thirdPartyRenew = Read-Host "Do you want to renew this account with a self-signed certificate for mitigation? (Y/N): "

            if ($thirdPartyRenew -ne "Y" -and $thirdPartyRenew -ne 'y') {
                continue
            }
        }

        Write-Output ""
        $renew = Read-Host "Renew RunAs certificate for account $($a.ResourceId) (Y/N): "

        if ($renew -eq "Y" -or $renew -eq 'y') {
            Remediate-Account $a
            ++$count
        }
    }

    Write-Output ""
    Write-Output "======================"
    Write-Output "Completed mitigation. Total accounts processed -$($count)"
    Write-Output "======================"    
}

function Remediate-Account {
    param ([AutomationAccount]$account)

    Write-Output ""
    Write-Output "Started Rotating certificate for $($account.ResourceId)"
    Select-AzSubscription -SubscriptionId $account.SubscriptionId > $null

    $appId = $account.RunAsAppId
    $subId = $account.SubscriptionId
    $resourceGroup = $account.ResourceGroup
    $accountName = $account.Name

    # To remediate AAD App, user should have Automation Contributor role access and Application Administrator permission on AAD App
    # Checking user write access on automation account.
    $writePermission = Check-WriteAccessOnAutomationAccount $account
    if(!$writePermission ) {
        Write-Error "Unable to mitigate $($account.ResourceId) - Reason: User does not have write permission on the Automation account. Please check prerequisites."
        return
    }

    Write-Verbose "User has write permission on Automation account $($account.ResourceId)"

    Write-Debug "Creating new certificate"
    $certName = "$($accountName)_$($resourceGroup)_$($subId)"
    $cert = New-SelfSignedCertificate -KeyUsageProperty All -Provider "Microsoft Enhanced RSA and AES Cryptographic Provider" -FriendlyName $certName -Subject "DC=$certName" -HashAlgorithm SHA256 -KeyLength 2048 -KeyExportPolicy ExportableEncrypted
    $certString = [convert]::tobase64string($cert.RawData)

    Add-Type -AssemblyName System.Web
    $securePassword = ConvertTo-SecureString $([System.Web.Security.Membership]::GeneratePassword(25, 10)) -AsPlainText -Force
    Export-PfxCertificate -FilePath "$pwd\$certName.pfx" -Cert $cert -Password $securePassword -NoProperties > $null    

    try {

        Write-Verbose "Deleting existing certs on app with AppId: $appId"
        $creds = Get-AzADAppCredential -ApplicationId $appId | Where-Object { $_.Type -eq "AsymmetricX509Cert" }
        foreach ($cred in $creds) {
            Remove-AzADAppCredential -ApplicationId $appId -KeyId ([Guid]::Parse($cred.KeyId))
            if (!$?) {
                Write-Error "Unable to mitigate $($account.ResourceId) - Reason: Failed to remove existing certificates from the AAD application. Please check prerequisites."
                return
            }
        }   
        
        Write-Verbose "Adding the new certificate on the AAD application"
        New-AzADAppCredential -ApplicationId $appId -CertValue $certString -StartDate $cert.NotBefore -EndDate $cert.NotAfter > $null
        if (!$?) {
            Write-Error "Unable to mitigate $($account.ResourceId) - Reason: Failed to add new certificate to the AAD application. Please check prerequisites."
            return
        }        
    }
    catch {
        Write-Error -Message "Unable to mitigate, error while accessing the App. Error Message: $($Error[0].Exception.Message)"
        return        
    }

    Write-Verbose "Creating the RunAs certificate asset"
    Remove-AzAutomationCertificate -AutomationAccountName $accountName -ResourceGroupName $resourceGroup -Name "AzureRunAsCertificate" -ErrorAction SilentlyContinue > $null
    New-AzAutomationCertificate -AutomationAccountName $accountName -ResourceGroupName $resourceGroup -Name "AzureRunAsCertificate" -Exportable -Path "$pwd\$certName.pfx" -Password $securePassword > $null
    if (!$?) {
        Write-Error "Unable to mitigate $($account.ResourceId) - Reason: Failed to update automation account with new runas certificate, may be due to Network or Permission issue."
        Write-Error "Please check prerequisites and rerun the script or mitigate manually. As certificate is already rotated in AAD App, jobs may fail until RunAs Account is updated with new certificate "
        return
    }

    Write-Verbose "Update the RunAs connection"
    Set-AzAutomationConnectionFieldValue -AutomationAccountName $accountName -ResourceGroupName $resourceGroup -Name "AzureRunAsConnection" -ConnectionFieldName CertificateThumbprint -Value $cert.Thumbprint > $null
    if (!$?) {
        Write-Error "Unable to mitigate $($account.ResourceId) - Reason: Failed to update automation account with new runas certificate, may be due to Network or Permission issue."
        Write-Error "Please check prerequisites and rerun the script or mitigate manually. As certificate is already rotated in AAD App, jobs may fail until RunAs Account is updated with new certificate "
        return
    }

    Write-Output "Successfully mitigated account $($account.ResourceId) . If you are using RunAs Connection in Hybrid Jobs, please follow  https://docs.microsoft.com/en-us/azure/automation/automation-hrw-run-runbooks to install latest RunAs Certificate on Hybrid Workers. "
    Write-Output ""
}

function Check-WriteAccessOnAutomationAccount {
    param ([AutomationAccount]$account)

    $resourceGroup = $account.ResourceGroup
    $accountName = $account.Name

    #To remidiate AAD App,user should have Automation Contributor role access and admin permission on AAD App
    # Checking user write access on automation account.
    $VariableName = "Remediation_AAD"+ $(Get-Random)
    $var = Get-AzAutomationVariable -ResourceGroupName $resourceGroup -AutomationAccountName $accountName -Name $VariableName -ErrorAction SilentlyContinue > $null
    while( $null -ne $var)
    {
        $VariableName = "Remediation_AAD"+ $(Get-Random)
        $var = Get-AzAutomationVariable -ResourceGroupName $resourceGroup -AutomationAccountName $accountName -Name $VariableName -ErrorAction SilentlyContinue > $null
    }

    if( $null -eq $var) {
        $var = New-AzAutomationVariable -ResourceGroupName $resourceGroup -AutomationAccountName $accountName -Name $VariableName -Value $VariableName -Encrypted $false
        if( $null -ne $var) {
            Remove-AzAutomationVariable -ResourceGroupName $resourceGroup -AutomationAccountName $accountName -Name $VariableName
            return $true;
        }
    }

    return $false
}

function ParseResourceId {
    param (
       [string]$resourceID
   )
   $array = $resourceID.Split('/')
   $indexSubscriptionId = 0..($array.Length -1) | where {$array[$_] -ieq 'subscriptions'}
   $indexResourceGroup = 0..($array.Length -1) | where {$array[$_] -ieq 'resourcegroups'}
   $result = $array.get($indexSubscriptionId+1), $array.get($indexResourceGroup+1), $array.get($array.Length -1)
   return $result
}


# Start point for the script
Show-Description

if (! $NoLogin ) {
    Connect-AzAccount -Environment $Env -ErrorAction Stop > $null
}
$MsGraphEndpoint = Get-MSGraphEndpoint $Env
$MsGraphToken = (Get-AzAccessToken -ResourceUrl $MsGraphEndpoint).Token

if(![string]::IsNullOrWhiteSpace($AppId)){
    Write-Output "Start Assessment for given AAD AppID."
    # Assess given Aad App ID and mitigate if it belong to Azure automation.
    Assess-ImpactByAppId

    if ( ! $NoMitigation) {
        Mitigate-Incident $ImpactedAccounts
    } else {
        if (! [string]::IsNullOrEmpty($ImpactedAccounts)) {
            Write-Output "Impacted Accounts:"
            Write-Output "$ImpactedAccounts"
        } else {
            Write-Output "No accounts are impacted"
        }
    }
} elseif ($null -ne $SubscriptionIds -and $SubscriptionIds.Count -ne 0) {
    Write-Output "Start Assessment for given Subscriptions."
    # Assess all the given subscriptions and mitigate all the App Id's belong to Azure automation
    Assess-Impact

    if ( ! $NoMitigation) {
        Mitigate-Incident $ImpactedAccounts
    } else {
        if (! [string]::IsNullOrEmpty($ImpactedAccounts)) {
            Write-Output "Impacted Accounts:"
            Write-Output "$ImpactedAccounts"
        } else {
            Write-Output "No accounts are impacted"
        }
    }
}



